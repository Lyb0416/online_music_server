package com.lyb.olinemusicserver.algorithm;

public class TreeNode {
    public float val;
    int id;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    public TreeNode(int id, float similarity) {
        this.id = id;
        this.val = similarity;
    }

}
/**
 * =========================为什么用最大堆维护最小的K个数================================
 * 目标：维护最小的 K 个元素       假设我们要在一堆数字里随时记住最小的 3 个数字，比如：
 *
 * 数字序列：5, 3, 8, 2, 6, 1       K = 3
 *
 * 最终我们希望保留 [1, 2, 3]，即最小的 3 个数。
 *
 * 方案 1：用最小堆   最小堆的特点：堆顶是最小值。
 *
 * 我们想维护最小的 3 个数：
 *
 * 插入 5 → 堆 [5]
 *
 * 插入 3 → 堆 [3,5]
 *
 * 插入 8 → 堆 [3,5,8]
 *
 * 插入 2 → 我们要看堆里哪个元素最大，因为 K 个最小元素中最大那一个要被替换。
 * 但是最小堆只能快速找到最小值，不方便找最大值，需要遍历堆去找最大值 → 效率低。
 *
 * 结论：用最小堆管理“最小的 K 个元素”，每次要替换最大值时不好操作。
 *
 * 方案 2：用最大堆
 *
 * 最大堆的特点：堆顶是最大值。
 *
 * 思路：我们只保留 K 个元素，每次保证堆顶是这 K 个元素里最大的。
 *
 * 插入数字：
 *
 * 插入 5 → 堆 [5]
 *
 * 插入 3 → 堆 [5,3] → 堆顶是 5
 *
 * 插入 8 → 堆 [8,3,5] → 堆顶是 8
 *
 * 插入 2 → 2 比堆顶 8 小 → 替换堆顶，调整堆 → 堆变成 [5,3,2]
 * ✅ 完全不用遍历找最大值，堆顶就是最大值。
 *
 * 插入 6 → 6 比堆顶 5 大 → 舍弃，继续保留最小的 3 个数 [2,3,5]
 */
